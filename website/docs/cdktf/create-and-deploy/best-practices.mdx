---
page_title: "Best Practices"
description: Build robust applications for production use cases. How to manage secrets, build constructs, design stacks, and more.
---

# CDK for Terraform Best Practices

There are many ways to structure your CDK for Terraform (CDKTF) application. The structure you choose depends largely on the best practices for your chosen programming language and your use case. However, we recommend using the following principles to build robust, production-ready applications.

## Read Secrets with Terraform Variables

Secrets appear in your synthesized CDKTF code when you read them directly from environment variables or from files with normal system access. This introduces risk, especially if you are checking the synthesized configuration into a version control system. To mitigate this, [use the `TerraformVariable` construct](/cdktf/concepts/variables-and-outputs#input-variables) to read secrets. Terraform uses the values in `TerraformVariable` directly at execution time, so CDKTF does not write them to the synthesized `cdktf.json` file.

The following example uses a Terraform variable to read the sensitive admin password instead of reading it directly from an environment variable.

<CodeTabs>

```ts
import { Construct } from "constructs";
import { App, TerraformStack, TerraformVariable } from "cdktf";
import { MyResource } from "./lib";

class MyStack extends TerraformStack {
  constructor(scope: Construct, name: string) {
    super(scope, name);

    const adminPassword = new TerraformVariable(this, "adminPassword", {
      type: "string",
      description: "Admin password for the instance",
      sensitive: true,
    });

    new MyResource(this, "hello", {
      adminPassword: adminPassword.value, // use this instead of process.env.ADMIN_PASSWORD
    });
  }
}

const app = new App();
new MyStack(app, "my-stack");
app.synth();
```

```python
from constructs import Construct
from cdktf import App, TerraformStack, TerraformVariable
from my_constructs import MyResource

class MyStack(TerraformStack):
    def __init__(self, scope, name):
        super().__init__(scope, name)

        admin_password = TerraformVariable(self, "adminPassword",
            type="string",
            description="Admin password for the instance",
            sensitive=True
        )

        MyResource(self, "hello",
            admin_password=admin_password.value
        )

app = App()
MyStack(app, "my-stack")
app.synth()
```

```java
import software.constructs.Construct;
import com.hashicorp.cdktf.App;
import com.hashicorp.cdktf.TerraformStack;
import com.hashicorp.cdktf.TerraformVariable;
import com.mycompany.app.MyResource;

public class MyStack extends TerraformStack {
    public MyStack(Construct scope, String name) {
        super(scope, name);

        TerraformVariable adminPassword = TerraformVariable.Builder.create(this, "adminPassword")
                .type("string")
                .description("Admin password for the instance")
                .sensitive(true)
                .build();

        MyResource.Builder.create(this, "hello")
                .adminPassword(adminPassword.getValue())
                .build();
    }
}

App app = new App();
new MyStack(app, "my-stack");
app.synth();
```

```csharp
using Constructs;
using HashiCorp.Cdktf;
using MyConstructs;

class MyStack : TerraformStack
{
    public MyStack(Construct scope, string name) : base(scope, name)
    {

        TerraformVariable adminPassword = new TerraformVariable(this, "adminPassword", new TerraformVariableConfig {
            Type = "string",
            Description = "Admin password for the instance",
            Sensitive = true
        });

        new MyResource(this, "hello", new MyResourceProps {
            AdminPassword = adminPassword.Value
        });
    }
}

App app = new App();
new MyStack(app, "my-stack");
app.Synth();
```

```go
import "github.com/aws/constructs-go/constructs"
import "github.com/hashicorp/terraform-cdk-go/cdktf"
import "github.com/myorg/myproject/myconstructs"

type myStack struct {
	terraformStack
}

func NewMyStack(scope construct, name *string) *myStack {
	this := &myStack{}
	NewTerraformStack_Override(this, scope, name)

	adminPassword := cdktf.NewTerraformVariable(this, jsii.String("adminPassword"), &cdktf.TerraformVariableConfig{
		type: jsii.String("string"),
		description: jsii.String("Admin password for the instance"),
		sensitive: jsii.Boolean(true),
	})

	myconstructs.NewMyResource(this, jsii.String("hello"), &myconstructs.MyResourceProps{
		adminPassword: adminPassword.value,
	})
	return this
}

app := cdktf.NewApp()
NewMyStack(app, jsii.String("my-stack"))
app.Synth()
```

</CodeTabs>

To pass a [Terraform variable through environment variables](/cli/config/environment-variables#tf_var_name), name the environment variable `TF_VAR_NAME`. For example, set `TF_VAR_adminPasword='<your password>'` in the execution environment.

If you use Terraform Cloud with [remote execution](/cloud-docs/run#remote-operations), you can store your secrets in Terraform Cloud. Refer to the Terraform Cloud documentation about [workspace variables](/cloud-docs/workspaces/variables/managing-variables#workspace-specific-variables) for more details.

We recommend using `TerraformVariable` only at the Stack level. Nesting them in custom constructs makes the interface unclear because some information may be passed into the constructor of the construct, while other data may be passed through a `TerraformVariable`. Nesting also changes the logical ID and makes it difficult to understand which `TerraformVariable` instances you must configure for the CDKTF program to run.

## Providers

A provider is a Terraform plugin that allows users to manage an external API. Provider plugins act as a translation layer that allows Terraform to communicate with many different cloud providers, databases, and services.

Use [pre-built providers](/cdktf/concepts/providers-and-resources#install-pre-built-providers) when possible. It can take several minutes to generate the code bindings for providers with very large schemas, so we offer several popular providers as pre-built packages. Pre-built providers are a performance optimization that reduces the time it takes to synthesize and run your application. You can also use pre-built providers as a peer dependency if you use open-source custom constructs.

Refer to the [CDKTF Provider GitHub repositories](https://github.com/orgs/hashicorp/repositories?q=cdktf-provider-) for a complete list of pre-built providers.

## Application Architecture

We recommend the following best practices when structuring your CDKTF application.

### Separate Business Units with Stacks

A [stack](/cdktf/concepts/stacks) represents a collection of infrastructure that CDKTF synthesizes as a dedicated Terraform configuration. Stacks allow you to separate the state management for multiple environments within an application. We recommend creating separate stacks for the following use cases:

- Deployment stages (development / staging / production)
- Business purposes (e-commerce / blog / data warehouse)
- Regions (eu-west-1 / us-east-1) if they deploy similar infrastructure, e.g. for high availability
- Software components (network / db / compute)
- Deployment cycles (databases and domain names / applications)

You do not always need to create a new class for each stack. For some use cases, it is more efficient to create a single stack class to define similar infrastructure and then pass arguments into the stack that customize the deployment. For example, you might create a class that creates AWS EC2 instances and then pass different regions and other configuration details based on the team or production stage that requires the infrastructure.

The following example customizes the same base stack for different business purposes and staging environments.

<CodeTabs>

```ts
import { App } from "cdktf";
import { NetworkingStack, Ecommerce, Blog } from "./lib";

const app = new App();
const devNetworking = new NetworkingStack(app, "networking-development", {
  // ...
});

// A single region is enough to create a development environment for each product.
new Ecommerce(app, "ecommerce-development", {
  vpcId: devNetworking.vpcId,
  subnets: devNetworking.subnets,
  region: "us-west-1",
});
new Blog(app, "blog-development", {
  vpcId: devNetworking.vpcId,
  subnets: devNetworking.subnets,
  region: "us-west-1",
});

// Staging environments require two ecommerce stacks in different regions
// to test the high availability features of the infrastructure.
const stageNetworking = new NetworkingStack(app, "networking-staging", {
  // ...
});
const ecommerceStaging = new Ecommerce(app, "ecommerce-staging-us", {
  vpcId: stageNetworking.vpcId,
  subnets: stageNetworking.subnets,
  region: "us-west-1",
});
new Ecommerce(app, "ecommerce-staging-eu", {
  vpcId: stageNetworking.vpcId,
  subnets: stageNetworking.subnets,
  region: "eu-central-1",
  databaseReplicationMaster: ecommerceStaging.databaseReplicationMaster,
});
new Blog(app, "blog-staging", {
  vpcId: stageNetworking.vpcId,
  subnets: stageNetworking.subnets,
  region: "us-west-1",
});
app.synth();
```

```python
from cdktf import App
from my_constructs import NetworkingStack, Ecommerce, Blog

app = App()
dev_networking = NetworkingStack(app, "networking-development", {})

# A single region is enough to create a development environment for each product.
Ecommerce(app, "ecommerce-development",
    vpc_id=dev_networking.vpc_id,
    subnets=dev_networking.subnets,
    region="us-west-1"
)
Blog(app, "blog-development",
    vpc_id=dev_networking.vpc_id,
    subnets=dev_networking.subnets,
    region="us-west-1"
)

# Staging environments require two ecommerce stacks in different regions
# to test the high availability features of the infrastructure.
stage_networking = NetworkingStack(app, "networking-staging", {})
ecommerce_staging = Ecommerce(app, "ecommerce-staging-us",
    vpc_id=stage_networking.vpc_id,
    subnets=stage_networking.subnets,
    region="us-west-1"
)
Ecommerce(app, "ecommerce-staging-eu",
    vpc_id=stage_networking.vpc_id,
    subnets=stage_networking.subnets,
    region="eu-central-1",
    database_replication_master=ecommerce_staging.database_replication_master
)
Blog(app, "blog-staging",
    vpc_id=stage_networking.vpc_id,
    subnets=stage_networking.subnets,
    region="us-west-1"
)
app.synth()
```

```java
import com.hashicorp.cdktf.App;
import com.mycompany.app.NetworkingStack;
import com.mycompany.app.Ecommerce;
import com.mycompany.app.Blog;

App app = new App();
NetworkingStack devNetworking = new NetworkingStack(app, "networking-development", Map.of());

// A single region is enough to create a development environment for each product.
// A single region is enough to create a development environment for each product.
Ecommerce.Builder.create(app, "ecommerce-development")
        .vpcId(devNetworking.getVpcId())
        .subnets(devNetworking.getSubnets())
        .region("us-west-1")
        .build();
Blog.Builder.create(app, "blog-development")
        .vpcId(devNetworking.getVpcId())
        .subnets(devNetworking.getSubnets())
        .region("us-west-1")
        .build();

// Staging environments require two ecommerce stacks in different regions
// to test the high availability features of the infrastructure.
NetworkingStack stageNetworking = new NetworkingStack(app, "networking-staging", Map.of());
Ecommerce ecommerceStaging = Ecommerce.Builder.create(app, "ecommerce-staging-us")
        .vpcId(stageNetworking.getVpcId())
        .subnets(stageNetworking.getSubnets())
        .region("us-west-1")
        .build();
Ecommerce.Builder.create(app, "ecommerce-staging-eu")
        .vpcId(stageNetworking.getVpcId())
        .subnets(stageNetworking.getSubnets())
        .region("eu-central-1")
        .databaseReplicationMaster(ecommerceStaging.getDatabaseReplicationMaster())
        .build();
Blog.Builder.create(app, "blog-staging")
        .vpcId(stageNetworking.getVpcId())
        .subnets(stageNetworking.getSubnets())
        .region("us-west-1")
        .build();
app.synth();
```

```csharp
using HashiCorp.Cdktf;
using MyConstructs;

App app = new App();
NetworkingStack devNetworking = new NetworkingStack(app, "networking-development", new Dictionary<string, object> { });

// A single region is enough to create a development environment for each product.evelopment environment for each product.
new Ecommerce(app, "ecommerce-development", new EcommerceProps {
    VpcId = devNetworking.VpcId,
    Subnets = devNetworking.Subnets,
    Region = "us-west-1"
});
new Blog(app, "blog-development", new BlogProps {
    VpcId = devNetworking.VpcId,
    Subnets = devNetworking.Subnets,
    Region = "us-west-1"
});

// Staging environments require two ecommerce stacks in different regions
// to test the high availability features of the infrastructure.
NetworkingStack stageNetworking = new NetworkingStack(app, "networking-staging", new Dictionary<string, object> { });
Ecommerce ecommerceStaging = new Ecommerce(app, "ecommerce-staging-us", new EcommerceProps {
    VpcId = stageNetworking.VpcId,
    Subnets = stageNetworking.Subnets,
    Region = "us-west-1"
});
new Ecommerce(app, "ecommerce-staging-eu", new EcommerceProps {
    VpcId = stageNetworking.VpcId,
    Subnets = stageNetworking.Subnets,
    Region = "eu-central-1",
    DatabaseReplicationMaster = ecommerceStaging.DatabaseReplicationMaster
});
new Blog(app, "blog-staging", new BlogProps {
    VpcId = stageNetworking.VpcId,
    Subnets = stageNetworking.Subnets,
    Region = "us-west-1"
});
app.Synth();
```

```go
import "github.com/hashicorp/terraform-cdk-go/cdktf"
import "github.com/myorg/myproject/myconstructs"

app := cdktf.NewApp()
devNetworking := myconstructs.NewNetworkingStack(app, jsii.String("networking-development"), map[string]interface{}{
})

// A single region is enough to create a development environment for each product.
myconstructs.NewEcommerce(app, jsii.String("ecommerce-development"), &myconstructs.ecommerceProps{
	vpcId: devNetworking.vpcId,
	subnets: devNetworking.subnets,
	region: jsii.String("us-west-1"),
})
myconstructs.NewBlog(app, jsii.String("blog-development"), &myconstructs.blogProps{
	vpcId: devNetworking.vpcId,
	subnets: devNetworking.subnets,
	region: jsii.String("us-west-1"),
})

// Staging environments require two ecommerce stacks in different regions
// to test the high availability features of the infrastructure.
stageNetworking := myconstructs.NewNetworkingStack(app, jsii.String("networking-staging"), map[string]interface{}{
})
ecommerceStaging := myconstructs.NewEcommerce(app, jsii.String("ecommerce-staging-us"), &myconstructs.ecommerceProps{
	vpcId: stageNetworking.vpcId,
	subnets: stageNetworking.subnets,
	region: jsii.String("us-west-1"),
})
myconstructs.NewEcommerce(app, jsii.String("ecommerce-staging-eu"), &myconstructs.ecommerceProps{
	vpcId: stageNetworking.vpcId,
	subnets: stageNetworking.subnets,
	region: jsii.String("eu-central-1"),
	databaseReplicationMaster: ecommerceStaging.databaseReplicationMaster,
})
myconstructs.NewBlog(app, jsii.String("blog-staging"), &myconstructs.blogProps{
	vpcId: stageNetworking.vpcId,
	subnets: stageNetworking.subnets,
	region: jsii.String("us-west-1"),
})
app.Synth()
```

</CodeTabs>

### Create Extensible Constructs

[Constructs](/cdktf/concepts/constructs) let you abstract common behavior into reusable classes. If you have no reason to limit the extensibility of a construct, you should default to making it as easy as possible to overwrite custom behavior, while still providing good standard defaults.

In some cases, you can use interfaces from the generated provider bindings to allow users to customize the configuration. In very complex constructs, we recommend using methods to encapsulate behavior. For example, you can create a method that derives default values for the configuration. This lets users extend the base class and overwrite the behavior in a central location.

The following example exposes configuration options for the S3 bucket resource within the construct. It also creates a second construct class that overwrites the default naming behavior.

<CodeTabs>

```ts
import { Construct } from "constructs";
import { s3 } from "@cdktf/provider-aws";

export class MyS3Bucket extends Construct {
  constructor(
    protected scope: Construct,
    protected id: string,
    protected s3Options: s3.S3BucketConfig
  ) {
    super(scope, id);
    new s3.S3Bucket(this, "MyBucket", {
      ...s3Options,
      bucket: this.getBucketName(),
      versioning: { enabled: true },
    });
  }

  public getBucketName(): string {
    return this.s3Options.bucket || `${this.id}-bucket`;
  }
}

export class SimpleS3Bucket extends MyS3Bucket {
  // New behaviour was patched in by overwriting
  public getBucketName() {
    return this.id;
  }
}
```

```python
from constructs import Construct
from cdktf_cdktf_provider_aws import s3

class MyS3Bucket(Construct):
    def __init__(self, scope, id, *, accelerationStatus=None, acl=None, arn=None, bucket=None, bucketPrefix=None, forceDestroy=None, hostedZoneId=None, id=None, objectLockEnabled=None, policy=None, requestPayer=None, tags=None, tagsAll=None, corsRule=None, grant=None, lifecycleRule=None, logging=None, objectLockConfiguration=None, replicationConfiguration=None, serverSideEncryptionConfiguration=None, versioning=None, website=None, dependsOn=None, count=None, provider=None, lifecycle=None):
        super().__init__(scope, id)
        s3.S3Bucket(self, "MyBucket",
            (SpreadAssignment ...s3Options
              accelerationStatus=accelerationStatus, acl=acl, arn=arn, bucket=bucket, bucketPrefix=bucketPrefix, forceDestroy=forceDestroy, hostedZoneId=hostedZoneId, id=id, objectLockEnabled=objectLockEnabled, policy=policy, requestPayer=requestPayer, tags=tags, tagsAll=tagsAll, corsRule=corsRule, grant=grant, lifecycleRule=lifecycleRule, logging=logging, objectLockConfiguration=objectLockConfiguration, replicationConfiguration=replicationConfiguration, serverSideEncryptionConfiguration=serverSideEncryptionConfiguration, versioning=versioning, website=website, dependsOn=dependsOn, count=count, provider=provider, lifecycle=lifecycle),
            bucket=self.get_bucket_name(),
            versioning=s3.S3BucketVersioning(enabled=True)
        )

    def get_bucket_name(self):
        return self.s3_options.bucket || f"{this.id}-bucket"

class SimpleS3Bucket(MyS3Bucket):
    # New behaviour was patched in by overwriting
    def get_bucket_name(self):
        return self.id
```

```java
import software.constructs.Construct;
import com.hashicorp.cdktf.providers.aws.s3.*;

public class MyS3Bucket extends Construct {
    public MyS3Bucket(Construct scope, String id, S3BucketConfig s3Options) {
        super(scope, id);
        S3Bucket.Builder.create(this, "MyBucket")
                (SpreadAssignment ...s3Options
                  s3Options)
                .bucket(this.getBucketName())
                .versioning(S3BucketVersioning.builder().enabled(true).build())
                .build();
    }

    public String getBucketName() {
        return this.s3Options.getBucket() || String.format("%s-bucket", this.id);
    }
}

public class SimpleS3Bucket extends MyS3Bucket {
    // New behaviour was patched in by overwriting
    public String getBucketName() {
        return this.id;
    }
}
```

```csharp
using Constructs;
using HashiCorp.Cdktf.Providers.Aws.s3;

class MyS3Bucket : Construct
{
    public MyS3Bucket(Construct scope, string id, S3BucketConfig s3Options) : base(scope, id)
    {
        new S3Bucket(this, "MyBucket", new S3BucketConfig {
            (SpreadAssignment ...s3Options
              s3Options),
            Bucket = GetBucketName(),
            Versioning = new S3BucketVersioning { Enabled = true }
        });
    }

    public string GetBucketName()
    {
        return S3Options.Bucket || $"{this.id}-bucket";
    }
}

class SimpleS3Bucket : MyS3Bucket
{
    // New behaviour was patched in by overwriting
    public string GetBucketName()
    {
        return Id;
    }
}
```

```go
import "github.com/aws/constructs-go/constructs"
import "github.com/hashicorp/cdktf-provider-aws-go/aws"

type MyS3Bucket struct {
	construct
}

func NewMyS3Bucket(scope construct, id *string, s3Options s3BucketConfig) *MyS3Bucket {
	this := &MyS3Bucket{}
	newConstruct_Override(this, scope, id)
  config := s3Options
  config.bucket = this.getBucketName()
  config.versioning = &s3BucketVersioning{
			enabled: jsii.Boolean(true),
		},
	aws.S3.NewS3Bucket(this, jsii.String("MyBucket"), &config)
	return this
}

func (this *MyS3Bucket) getBucketName() *string {
	return jsii.String(this.*s3Options.bucket || fmt.Sprintf("%v-bucket", this.*id))
}

type SimpleS3Bucket struct {
	myS3Bucket
}

// New behaviour was patched in by overwriting
func (this *SimpleS3Bucket) getBucketName() *string {
	return this.*id
}
```

</CodeTabs>

### Use Projen to Distribute Constructs

If your code is hosted on Github and you want to distribute it as a CDKTF construct, you can use [projen](https://github.com/projen/projen) to create a repository with all required tooling set up for you. You can run `npx projen new cdktf-construct` in a new folder, and the created project will be ready to use. Projen has built-in options to [publish constructs to all registries](https://github.com/projen/projen/blob/main/src/cdk/jsii-project.ts#L48).

If you want to deploy your CDKTF construct as a Terraform module, we recommend [`projen-cdktf-hybrid-construct`](https://github.com/DanielMSchmidt/projen-cdktf-hybrid-construct).
