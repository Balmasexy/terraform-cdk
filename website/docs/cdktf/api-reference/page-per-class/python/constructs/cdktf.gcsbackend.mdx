 GcsBackend <a name="GcsBackend" id="cdktf.GcsBackend"></a>

# Initializers <a name="Initializers" id="cdktf.GcsBackend.Initializer"></a>

```python
import cdktf

cdktf.GcsBackend(
  scope: Construct,
  bucket: str,
  access_token: str = None,
  credentials: str = None,
  encryption_key: str = None,
  impersonate_service_account: str = None,
  impersonate_service_account_delegates: typing.List[str] = None,
  prefix: str = None
)
```

| **Name** | **Type** | **Description** |
| --- | --- | --- |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.scope">scope</a></code> | <code>constructs.Construct</code> | *No description.* |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.bucket">bucket</a></code> | <code>str</code> | (Required) The name of the GCS bucket. |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.accessToken">access_token</a></code> | <code>str</code> | (Optional) A temporary [OAuth 2.0 access token] obtained from the Google Authorization server, i.e. the Authorization: Bearer token used to authenticate HTTP requests to GCP APIs. This is an alternative to credentials. If both are specified, access_token will be used over the credentials field. |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.credentials">credentials</a></code> | <code>str</code> | (Optional) Local path to Google Cloud Platform account credentials in JSON format. |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.encryptionKey">encryption_key</a></code> | <code>str</code> | (Optional) A 32 byte base64 encoded 'customer supplied encryption key' used to encrypt all state. |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.impersonateServiceAccount">impersonate_service_account</a></code> | <code>str</code> | (Optional) The service account to impersonate for accessing the State Bucket. |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.impersonateServiceAccountDelegates">impersonate_service_account_delegates</a></code> | <code>typing.List[str]</code> | (Optional) The delegation chain for an impersonating a service account. |
| <code><a href="#cdktf.GcsBackend.Initializer.parameter.prefix">prefix</a></code> | <code>str</code> | (Optional) GCS prefix inside the bucket. |

---

## `scope`<sup>Required</sup> <a name="scope" id="cdktf.GcsBackend.Initializer.parameter.scope"></a>

- *Type:* constructs.Construct

---

## `bucket`<sup>Required</sup> <a name="bucket" id="cdktf.GcsBackend.Initializer.parameter.bucket"></a>

- *Type:* str

(Required) The name of the GCS bucket.

This name must be globally unique.

---

## `access_token`<sup>Optional</sup> <a name="access_token" id="cdktf.GcsBackend.Initializer.parameter.accessToken"></a>

- *Type:* str

(Optional) A temporary [OAuth 2.0 access token] obtained from the Google Authorization server, i.e. the Authorization: Bearer token used to authenticate HTTP requests to GCP APIs. This is an alternative to credentials. If both are specified, access_token will be used over the credentials field.

---

## `credentials`<sup>Optional</sup> <a name="credentials" id="cdktf.GcsBackend.Initializer.parameter.credentials"></a>

- *Type:* str

(Optional) Local path to Google Cloud Platform account credentials in JSON format.

If unset, Google Application Default Credentials are used.
The provided credentials must have Storage Object Admin role on the bucket.

Warning: if using the Google Cloud Platform provider as well,
it will also pick up the GOOGLE_CREDENTIALS environment variable.

---

## `encryption_key`<sup>Optional</sup> <a name="encryption_key" id="cdktf.GcsBackend.Initializer.parameter.encryptionKey"></a>

- *Type:* str

(Optional) A 32 byte base64 encoded 'customer supplied encryption key' used to encrypt all state.

---

## `impersonate_service_account`<sup>Optional</sup> <a name="impersonate_service_account" id="cdktf.GcsBackend.Initializer.parameter.impersonateServiceAccount"></a>

- *Type:* str

(Optional) The service account to impersonate for accessing the State Bucket.

You must have roles/iam.serviceAccountTokenCreator role on that account for the impersonation to succeed.
If you are using a delegation chain, you can specify that using the impersonate_service_account_delegates field.
Alternatively, this can be specified using the GOOGLE_IMPERSONATE_SERVICE_ACCOUNT environment variable.

---

## `impersonate_service_account_delegates`<sup>Optional</sup> <a name="impersonate_service_account_delegates" id="cdktf.GcsBackend.Initializer.parameter.impersonateServiceAccountDelegates"></a>

- *Type:* typing.List[str]

(Optional) The delegation chain for an impersonating a service account.

---

## `prefix`<sup>Optional</sup> <a name="prefix" id="cdktf.GcsBackend.Initializer.parameter.prefix"></a>

- *Type:* str

(Optional) GCS prefix inside the bucket.

Named states for workspaces are stored in an object called <prefix>/<name>.tfstate.

---

# Methods <a name="Methods" id="Methods"></a>

| **Name** | **Description** |
| --- | --- |
| <code><a href="#cdktf.GcsBackend.toString">to_string</a></code> | Returns a string representation of this construct. |
| <code><a href="#cdktf.GcsBackend.addOverride">add_override</a></code> | *No description.* |
| <code><a href="#cdktf.GcsBackend.overrideLogicalId">override_logical_id</a></code> | Overrides the auto-generated logical ID with a specific ID. |
| <code><a href="#cdktf.GcsBackend.resetOverrideLogicalId">reset_override_logical_id</a></code> | Resets a previously passed logical Id to use the auto-generated logical id again. |
| <code><a href="#cdktf.GcsBackend.toMetadata">to_metadata</a></code> | *No description.* |
| <code><a href="#cdktf.GcsBackend.toTerraform">to_terraform</a></code> | Adds this resource to the terraform JSON output. |
| <code><a href="#cdktf.GcsBackend.getRemoteStateDataSource">get_remote_state_data_source</a></code> | Creates a TerraformRemoteState resource that accesses this backend. |

---

## `to_string` <a name="to_string" id="cdktf.GcsBackend.toString"></a>

```python
def to_string() -> str
```

Returns a string representation of this construct.

## `add_override` <a name="add_override" id="cdktf.GcsBackend.addOverride"></a>

```python
def add_override(
  path: str,
  value: typing.Any
) -> None
```

### `path`<sup>Required</sup> <a name="path" id="cdktf.GcsBackend.addOverride.parameter.path"></a>

- *Type:* str

---

### `value`<sup>Required</sup> <a name="value" id="cdktf.GcsBackend.addOverride.parameter.value"></a>

- *Type:* typing.Any

---

## `override_logical_id` <a name="override_logical_id" id="cdktf.GcsBackend.overrideLogicalId"></a>

```python
def override_logical_id(
  new_logical_id: str
) -> None
```

Overrides the auto-generated logical ID with a specific ID.

### `new_logical_id`<sup>Required</sup> <a name="new_logical_id" id="cdktf.GcsBackend.overrideLogicalId.parameter.newLogicalId"></a>

- *Type:* str

The new logical ID to use for this stack element.

---

## `reset_override_logical_id` <a name="reset_override_logical_id" id="cdktf.GcsBackend.resetOverrideLogicalId"></a>

```python
def reset_override_logical_id() -> None
```

Resets a previously passed logical Id to use the auto-generated logical id again.

## `to_metadata` <a name="to_metadata" id="cdktf.GcsBackend.toMetadata"></a>

```python
def to_metadata() -> typing.Any
```

## `to_terraform` <a name="to_terraform" id="cdktf.GcsBackend.toTerraform"></a>

```python
def to_terraform() -> typing.Any
```

Adds this resource to the terraform JSON output.

## `get_remote_state_data_source` <a name="get_remote_state_data_source" id="cdktf.GcsBackend.getRemoteStateDataSource"></a>

```python
def get_remote_state_data_source(
  scope: Construct,
  name: str,
  _fromstack: str
) -> TerraformRemoteState
```

Creates a TerraformRemoteState resource that accesses this backend.

### `scope`<sup>Required</sup> <a name="scope" id="cdktf.GcsBackend.getRemoteStateDataSource.parameter.scope"></a>

- *Type:* constructs.Construct

---

### `name`<sup>Required</sup> <a name="name" id="cdktf.GcsBackend.getRemoteStateDataSource.parameter.name"></a>

- *Type:* str

---

### `_fromstack`<sup>Required</sup> <a name="_fromstack" id="cdktf.GcsBackend.getRemoteStateDataSource.parameter._fromStack"></a>

- *Type:* str

---

# Static Functions <a name="Static Functions" id="Static Functions"></a>

| **Name** | **Description** |
| --- | --- |
| <code><a href="#cdktf.GcsBackend.isConstruct">is_construct</a></code> | Checks if `x` is a construct. |
| <code><a href="#cdktf.GcsBackend.isBackend">is_backend</a></code> | *No description.* |

---

## `is_construct` <a name="is_construct" id="cdktf.GcsBackend.isConstruct"></a>

```python
import cdktf

cdktf.GcsBackend.is_construct(
  x: typing.Any
)
```

Checks if `x` is a construct.

Use this method instead of `instanceof` to properly detect `Construct`
instances, even when the construct library is symlinked.

Explanation: in JavaScript, multiple copies of the `constructs` library on
disk are seen as independent, completely different libraries. As a
consequence, the class `Construct` in each copy of the `constructs` library
is seen as a different class, and an instance of one class will not test as
`instanceof` the other class. `npm install` will not create installations
like this, but users may manually symlink construct libraries together or
use a monorepo tool: in those cases, multiple copies of the `constructs`
library can be accidentally installed, and `instanceof` will behave
unpredictably. It is safest to avoid using `instanceof`, and using
this type-testing method instead.

### `x`<sup>Required</sup> <a name="x" id="cdktf.GcsBackend.isConstruct.parameter.x"></a>

- *Type:* typing.Any

Any object.

---

## `is_backend` <a name="is_backend" id="cdktf.GcsBackend.isBackend"></a>

```python
import cdktf

cdktf.GcsBackend.is_backend(
  x: typing.Any
)
```

### `x`<sup>Required</sup> <a name="x" id="cdktf.GcsBackend.isBackend.parameter.x"></a>

- *Type:* typing.Any

---

# Properties <a name="Properties" id="Properties"></a>

| **Name** | **Type** | **Description** |
| --- | --- | --- |
| <code><a href="#cdktf.GcsBackend.property.node">node</a></code> | <code>constructs.Node</code> | The tree node. |
| <code><a href="#cdktf.GcsBackend.property.cdktfStack">cdktf_stack</a></code> | <code><a href="#cdktf.TerraformStack">TerraformStack</a></code> | *No description.* |
| <code><a href="#cdktf.GcsBackend.property.fqn">fqn</a></code> | <code>str</code> | *No description.* |
| <code><a href="#cdktf.GcsBackend.property.friendlyUniqueId">friendly_unique_id</a></code> | <code>str</code> | *No description.* |

---

## `node`<sup>Required</sup> <a name="node" id="cdktf.GcsBackend.property.node"></a>

```python
node: Node
```

- *Type:* constructs.Node

The tree node.

---

## `cdktf_stack`<sup>Required</sup> <a name="cdktf_stack" id="cdktf.GcsBackend.property.cdktfStack"></a>

```python
cdktf_stack: TerraformStack
```

- *Type:* <a href="#cdktf.TerraformStack">TerraformStack</a>

---

## `fqn`<sup>Required</sup> <a name="fqn" id="cdktf.GcsBackend.property.fqn"></a>

```python
fqn: str
```

- *Type:* str

---

## `friendly_unique_id`<sup>Required</sup> <a name="friendly_unique_id" id="cdktf.GcsBackend.property.friendlyUniqueId"></a>

```python
friendly_unique_id: str
```

- *Type:* str

---

