 Tokenization <a name="Tokenization" id="cdktf.Tokenization"></a>

Less oft-needed functions to manipulate Tokens.

# Initializers <a name="Initializers" id="cdktf.Tokenization.Initializer"></a>

```python
import cdktf

cdktf.Tokenization()
```

| **Name** | **Type** | **Description** |
| --- | --- | --- |

---


# Static Functions <a name="Static Functions" id="Static Functions"></a>

| **Name** | **Description** |
| --- | --- |
| <code><a href="#cdktf.Tokenization.isResolvable">is_resolvable</a></code> | Return whether the given object is an IResolvable object. |
| <code><a href="#cdktf.Tokenization.resolve">resolve</a></code> | Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays. |
| <code><a href="#cdktf.Tokenization.reverse">reverse</a></code> | Reverse any value into Resolvables, if possible. |
| <code><a href="#cdktf.Tokenization.reverseList">reverse_list</a></code> | Un-encode a Tokenized value from a list. |
| <code><a href="#cdktf.Tokenization.reverseMap">reverse_map</a></code> | Un-encode a Tokenized value from a map. |
| <code><a href="#cdktf.Tokenization.reverseNumber">reverse_number</a></code> | Un-encode a Tokenized value from a number. |
| <code><a href="#cdktf.Tokenization.reverseNumberList">reverse_number_list</a></code> | Un-encode a Tokenized value from a list. |
| <code><a href="#cdktf.Tokenization.reverseString">reverse_string</a></code> | Un-encode a string potentially containing encoded tokens. |
| <code><a href="#cdktf.Tokenization.stringifyNumber">stringify_number</a></code> | Stringify a number directly or lazily if it's a Token. |

---

## `is_resolvable` <a name="is_resolvable" id="cdktf.Tokenization.isResolvable"></a>

```python
import cdktf

cdktf.Tokenization.is_resolvable(
  obj: typing.Any
)
```

Return whether the given object is an IResolvable object.

This is different from Token.isUnresolved() which will also check for
encoded Tokens, whereas this method will only do a type check on the given
object.

### `obj`<sup>Required</sup> <a name="obj" id="cdktf.Tokenization.isResolvable.parameter.obj"></a>

- *Type:* typing.Any

---

## `resolve` <a name="resolve" id="cdktf.Tokenization.resolve"></a>

```python
import cdktf

cdktf.Tokenization.resolve(
  obj: typing.Any,
  resolver: ITokenResolver,
  scope: IConstruct,
  preparing: bool = None
)
```

Resolves an object by evaluating all tokens and removing any undefined or empty objects or arrays.

Values can only be primitives, arrays or tokens. Other objects (i.e. with methods) will be rejected.

### `obj`<sup>Required</sup> <a name="obj" id="cdktf.Tokenization.resolve.parameter.obj"></a>

- *Type:* typing.Any

The object to resolve.

---

### `resolver`<sup>Required</sup> <a name="resolver" id="cdktf.Tokenization.resolve.parameter.resolver"></a>

- *Type:* <a href="#cdktf.ITokenResolver">ITokenResolver</a>

The resolver to apply to any resolvable tokens found.

---

### `scope`<sup>Required</sup> <a name="scope" id="cdktf.Tokenization.resolve.parameter.scope"></a>

- *Type:* constructs.IConstruct

The scope from which resolution is performed.

---

### `preparing`<sup>Optional</sup> <a name="preparing" id="cdktf.Tokenization.resolve.parameter.preparing"></a>

- *Type:* bool
- *Default:* false

Whether the resolution is being executed during the prepare phase or not.

---

## `reverse` <a name="reverse" id="cdktf.Tokenization.reverse"></a>

```python
import cdktf

cdktf.Tokenization.reverse(
  x: typing.Any
)
```

Reverse any value into Resolvables, if possible.

### `x`<sup>Required</sup> <a name="x" id="cdktf.Tokenization.reverse.parameter.x"></a>

- *Type:* typing.Any

---

## `reverse_list` <a name="reverse_list" id="cdktf.Tokenization.reverseList"></a>

```python
import cdktf

cdktf.Tokenization.reverse_list(
  l: typing.List[str]
)
```

Un-encode a Tokenized value from a list.

### `l`<sup>Required</sup> <a name="l" id="cdktf.Tokenization.reverseList.parameter.l"></a>

- *Type:* typing.List[str]

---

## `reverse_map` <a name="reverse_map" id="cdktf.Tokenization.reverseMap"></a>

```python
import cdktf

cdktf.Tokenization.reverse_map(
  m: typing.Mapping[typing.Any]
)
```

Un-encode a Tokenized value from a map.

### `m`<sup>Required</sup> <a name="m" id="cdktf.Tokenization.reverseMap.parameter.m"></a>

- *Type:* typing.Mapping[typing.Any]

---

## `reverse_number` <a name="reverse_number" id="cdktf.Tokenization.reverseNumber"></a>

```python
import cdktf

cdktf.Tokenization.reverse_number(
  n: typing.Union[int, float]
)
```

Un-encode a Tokenized value from a number.

### `n`<sup>Required</sup> <a name="n" id="cdktf.Tokenization.reverseNumber.parameter.n"></a>

- *Type:* typing.Union[int, float]

---

## `reverse_number_list` <a name="reverse_number_list" id="cdktf.Tokenization.reverseNumberList"></a>

```python
import cdktf

cdktf.Tokenization.reverse_number_list(
  l: typing.List[typing.Union[int, float]]
)
```

Un-encode a Tokenized value from a list.

### `l`<sup>Required</sup> <a name="l" id="cdktf.Tokenization.reverseNumberList.parameter.l"></a>

- *Type:* typing.List[typing.Union[int, float]]

---

## `reverse_string` <a name="reverse_string" id="cdktf.Tokenization.reverseString"></a>

```python
import cdktf

cdktf.Tokenization.reverse_string(
  s: str
)
```

Un-encode a string potentially containing encoded tokens.

### `s`<sup>Required</sup> <a name="s" id="cdktf.Tokenization.reverseString.parameter.s"></a>

- *Type:* str

---

## `stringify_number` <a name="stringify_number" id="cdktf.Tokenization.stringifyNumber"></a>

```python
import cdktf

cdktf.Tokenization.stringify_number(
  x: typing.Union[int, float]
)
```

Stringify a number directly or lazily if it's a Token.

If it is an object (i.e., { Ref: 'SomeLogicalId' }), return it as-is.

### `x`<sup>Required</sup> <a name="x" id="cdktf.Tokenization.stringifyNumber.parameter.x"></a>

- *Type:* typing.Union[int, float]

---


